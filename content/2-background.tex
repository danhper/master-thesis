\chapter{Background}
\section{Source code representation}
The way we represent source code is very important in code clone detection,
as it affects greatly the algorithms that may be used to detect clones.k
In this section, we will explain the different ways in which source codes
can be represented.
\subsection{String representation}
The most common representation for a program is its string representation. It is
the representation that developer actually uses when editing a program, and
is therefore the easiest to obtain, as it is simply the raw program.
Listing~\ref{lis:add} is a function taking two numbers as input and returning
their sum.
\begin{lstlisting}[caption=\lstinline{add} function,label=lis:add]
int add(int a, int b) {
  return a + b;
}
\end{lstlisting}
The string representation of the above program would simply be
\begin{lstlisting}
"int add(int a, int b) {\nreturn a + b;\n}"
\end{lstlisting}
\subsection{Token representation}
While the string representation is an array of characters, the token
representation is an array of strings where each string in the array is a token
of the program. It is typically the representation that a lexer would return
while processing the source program. The above program would have the following
token representation.
\begin{lstlisting}
["int", "add", "(", "int", "a", ",", "int", "b",
 ")", "{", "return", "a", "+", "b", ";", "}"]
\end{lstlisting}
Token representation may, or may not keep whitespaces and other formatting
characters, but except for programming languages where whitespaces are significant,
such as Python, they are usually not included in the output.
\subsection{Tree representation}
There are two main tree representations for programs: concrete syntax trees and
abstract syntax trees. We will describe the two different type of trees and
there differences.
\subsubsection{Concrete Syntax Trees}
Concrete syntax trees are concrete in the sense that they keep all the syntactic
tokens of the program, such as commas, semi-colons or parentheses. It therefore
contains exactly the same tokens as the token representation, but the tokens
are organized as a tree, where the root is usually the entry of the program,
the nodes are usually statements or expressions and the leaves are identifiers
or literals. Figure~\ref{fig:add-cst} shows how Listing~\ref{lis:add} would be
represented as a concrete syntax tree.
\begin{figure}[tb]
  \begin{center}
    \includedot[height=5cm]{./diagrams/add-cst.dot}
    \caption{\label{fig:add-cst}Concrete Syntax Tree of \lstinline{add} function}
  \end{center}
\end{figure}
\subsubsection{Abstract Syntax Trees}
Abstract Syntax Trees (AST) are also a tree representation of the source code,
but as opposed to the concrete syntax tree, they do not preserve the host
language syntax, such as parentheses, and instead express these using the
structure of the tree.
AST are typically the what a parser returns when processing the source code, and
are one of the most common representation for various tasks on programs,
including clone detection.
Figure~\ref{fig:add-ast} shows the AST for Listing~\ref{lis:add}.
\begin{figure}[tb]
  \begin{center}
    \includedot[height=5cm]{./diagrams/add-ast.dot}
    \caption{\label{fig:add-ast}Abstract Syntax Tree of \lstinline{add} function}
  \end{center}
\end{figure}
\section{Code clone fundamentals}
In this section, we will first describe the different types of code clones
that appear in the literature, and that we will be using in this thesis.
We will then quickly view the different approaches to code clone detection,
and briefly discuss their strengths and weaknesses.
\subsection{Types of code clones}
It is important to define what is implied when two code fragments are
defined as clones. In the literature, code clones are usually
classified into four different types~\cite{Roy07asurvey}, from Type I to Type IV,
where Type I is the ``strongest'', meaning here that the two code fragments are
the most similar, while Type IV is the ``weakest'' --- the two code fragments
share less in common. We will now give a more precise definition of each code
clone type.
\subsubsection{Type I Clones}
Type I code clones types are clones where the code fragment are the same,
except for some variations that do not affect the logic, such as differences
in whitespaces or comments. In the literature, Type I clones are sometimes also
referred to as exact clones.
For example, let us consider the following code fragment.
\begin{lstlisting}[caption=Fibonacci function,label=lis:fibo]
int fibo(int n) {
  if (n <= 1) {
    return n;
  }
  return fibo(n - 1) + fibo(n - 2);
}
\end{lstlisting}

The following code fragment is considered to be a Type I clone.
\begin{lstlisting}
int fibo(int n) {
  if (n <= 1) { return n; } // base case of recursion
  return fibo(n-1)+
         fibo(n-2);
}
\end{lstlisting}

Although, as with the above example, line-by-line comparisons may not always
yield correct results for Type I clones, it is worth noting than if the two
fragments are pre-processed with a lexer, a simple token comparison should
normally be enough to detect this type of clones.
\subsubsection{Type II Clones}
Type II clones include the changes that can be involved in Type I clones, such
as layout and comments, but also include other changes, such as changes in
user-defined identifiers --- variable or function names. For example, the
following snippet would be a Type II clone for Listing~\ref{lis:fibo}:
\begin{lstlisting}
int fib(int x) {
  if (x <= 1) { return x; }
  return fib(x - 1) + fib(x - 2);
}
\end{lstlisting}
The function and parameter names, as well as the layout are different, but the
logic is exactly the same.
\subsubsection{Type III Clones}
Type III clones can have all the changes from type I and type II clones, but
may also have statement insertions, deletions or replacements.
Although Type III clones are usually copied from the same source code,
there is no agreement on a threshold on the number of changes to consider or not
two code fragments as type III clones. Some researchers therefore classify
type III code clones in categories such as very strong type III or weakly type
III~\cite{Sajnani:2016:SSC:2884781.2884877}.
Here is an example type III clone for Listing~\ref{lis:fibo}.
%
\begin{lstlisting}
int fib(int x) {
  int a = x;
  if (a <= 1) {
    return a;
  }
  return fib(a - 1) + fib(a - 2);
}
\end{lstlisting}

In the above code fragment, the code is completely copied from
Listing~\ref{lis:fibo}, except for a change in the identifier names, but the
second line has been inserted, making this code fragment a type III clone.
\subsubsection{Type IV Clones}
Type IV clones, also referred to as functional code clones, are two code
fragments implementing the same functionality with different approaches.
Unlike type I to III clones, type IV clones are usually not a result of
code copying, but rather of two programmers implementing the same functionality.
For example, as opposed to the recursive implementation of Fibonacci in
Listing~\ref{lis:fibo}, the following iterative implementation could be defined
to be a type IV clone.
\begin{lstlisting}[caption=Iterative Fibonacci,label=lis:iter-fibo]
int fib(int n) {
  int a = 0, b = 1;
  for (int i = 0; i < n; i++) {
    int tmp = a + b;
    a = b;
    b = tmp;
  }
  return a;
}
\end{lstlisting}
The two code fragments will return the same result for any $n \geq 0$ and are
therefore functional clones. Although the implemented functionality
is the same, there are no other common point in the implementations.
Furthermore, Listing~\ref{lis:fibo} and Listing~\ref{lis:iter-fibo} clearly
have different time complexities, but to the best of our knowledge, there
are no established convention to whether this kind of complexity changes
should be taken into account when deciding if two code fragments are, or not,
type IV code clones. In this thesis, we will therefore assume that as long
as two code fragments implement same functionality, they are type IV clones.
\subsection{Approaches to clone detection}
\section{Machine learning fundamentals}
\subsection{Skipgram model}
\subsection{Recurrent Neural Networks}
