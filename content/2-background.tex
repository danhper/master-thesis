\chapter{Background}
\section{\label{sec:code-representation} Source code representation}
The way we represent source code is very important in code clone detection,
as it affects greatly the algorithms that may be used to detect clones.k
In this section, we will explain the different ways in which source codes
can be represented.
\subsection{\label{ssec:string-representation} String representation}
The most common representation for a program is its string representation. It is
the representation that developer actually uses when editing a program, and
is therefore the easiest to obtain, as it is simply the raw program.
Listing~\ref{lis:add} is a function taking two numbers as input and returning
their sum.
\begin{lstlisting}[caption=\lstinline{add} function,label=lis:add]
int add(int a, int b) {
  return a + b;
}
\end{lstlisting}
The string representation of the above program would simply be
\begin{lstlisting}
"int add(int a, int b) {\nreturn a + b;\n}"
\end{lstlisting}
\subsection{\label{ssec:token-representation}Token representation}
While the string representation is an array of characters, the token
representation is an array of strings where each string in the array is a token
of the program. It is typically the representation that a lexer would return
while processing the source program. The above program would have the following
token representation.
\begin{lstlisting}
["int", "add", "(", "int", "a", ",", "int", "b",
 ")", "{", "return", "a", "+", "b", ";", "}"]
\end{lstlisting}
Token representation may, or may not keep whitespaces and other formatting
characters, but except for programming languages where whitespaces are significant,
such as Python, they are usually not included in the output.
\subsection{\label{ssec:tree-representation}Tree representation}
There are two main tree representations for programs: concrete syntax trees and
abstract syntax trees. We will describe the two different type of trees and
there differences.
\subsubsection{Concrete Syntax Trees}
Concrete syntax trees are concrete in the sense that they keep all the syntactic
tokens of the program, such as commas, semi-colons or parentheses. It therefore
contains exactly the same tokens as the token representation, but the tokens
are organized as a tree, where the root is usually the entry of the program,
the nodes are usually statements or expressions and the leaves are identifiers
or literals. Figure~\ref{fig:add-cst} shows how Listing~\ref{lis:add} would be
represented as a concrete syntax tree.
\begin{figure}[tb]
  \begin{center}
    \includedot[height=5cm]{./diagrams/add-cst.dot}
    \caption{\label{fig:add-cst}Concrete Syntax Tree of \lstinline{add} function}
  \end{center}
\end{figure}
\subsubsection{Abstract Syntax Trees}
Abstract Syntax Trees (AST) are also a tree representation of the source code,
but as opposed to the concrete syntax tree, they do not preserve the host
language syntax, such as parentheses, and instead express these using the
structure of the tree.
AST are typically the what a parser returns when processing the source code, and
are one of the most common representation for various tasks on programs,
including clone detection.
Figure~\ref{fig:add-ast} shows the AST for Listing~\ref{lis:add}.
\begin{figure}[tb]
  \begin{center}
    \includedot[height=5cm]{./diagrams/add-ast.dot}
    \caption{\label{fig:add-ast}Abstract Syntax Tree of \lstinline{add} function}
  \end{center}
\end{figure}
\section{Code clone fundamentals}
In this section, we will first describe the different types of code clones
that appear in the literature, and that we will be using in this thesis.
We will then view the different approaches to code clone detection that can be
found in the literature.
\subsection{Types of code clones}
It is important to define what is implied when two code fragments are
defined as clones. In the literature, code clones are usually
classified into four different types~\cite{Roy07asurvey}, from Type I to Type IV,
where Type I is the ``strongest'', meaning here that the two code fragments are
the most similar, while Type IV is the ``weakest'' --- the two code fragments
share less in common. We will now give a more precise definition of each code
clone type.
\subsubsection{Type I Clones}
Type I code clones types are clones where the code fragment are the same,
except for some variations that do not affect the logic, such as differences
in whitespaces or comments. In the literature, Type I clones are sometimes also
referred to as exact clones.
For example, let us consider the following code fragment.
\begin{lstlisting}[caption=Fibonacci function,label=lis:fibo]
int fibo(int n) {
  if (n <= 1) {
    return n;
  }
  return fibo(n - 1) + fibo(n - 2);
}
\end{lstlisting}

The following code fragment is considered to be a Type I clone.
\begin{lstlisting}
int fibo(int n) {
  if (n <= 1) { return n; } // base case of recursion
  return fibo(n-1)+
         fibo(n-2);
}
\end{lstlisting}

Although, as with the above example, line-by-line comparisons may not always
yield correct results for Type I clones, it is worth noting than if the two
fragments are pre-processed with a lexer, a simple token comparison should
normally be enough to detect this type of clones.
\subsubsection{Type II Clones}
Type II clones include the changes that can be involved in Type I clones, such
as layout and comments, but also include other changes, such as changes in
user-defined identifiers --- variable or function names. For example, the
following snippet would be a Type II clone for Listing~\ref{lis:fibo}:
\begin{lstlisting}
int fib(int x) {
  if (x <= 1) { return x; }
  return fib(x - 1) + fib(x - 2);
}
\end{lstlisting}
The function and parameter names, as well as the layout are different, but the
logic is exactly the same.
\subsubsection{Type III Clones}
Type III clones can have all the changes from type I and type II clones, but
may also have statement insertions, deletions or replacements.
Although Type III clones are usually copied from the same source code,
there is no agreement on a threshold on the number of changes to consider or not
two code fragments as type III clones. Some researchers therefore classify
type III code clones in categories such as very strong type III or weakly type
III~\cite{Sajnani:2016:SSC:2884781.2884877}.
Here is an example type III clone for Listing~\ref{lis:fibo}.
%
\begin{lstlisting}
int fib(int x) {
  int a = x;
  if (a <= 1) {
    return a;
  }
  return fib(a - 1) + fib(a - 2);
}
\end{lstlisting}

In the above code fragment, the code is completely copied from
Listing~\ref{lis:fibo}, except for a change in the identifier names, but the
second line has been inserted, making this code fragment a type III clone.
\subsubsection{Type IV Clones}
Type IV clones, also referred to as functional code clones, are two code
fragments implementing the same functionality with different approaches.
Unlike type I to III clones, type IV clones are usually not a result of
code copying, but rather of two programmers implementing the same functionality.
For example, as opposed to the recursive implementation of Fibonacci in
Listing~\ref{lis:fibo}, the following iterative implementation could be defined
to be a type IV clone.
\begin{lstlisting}[caption=Iterative Fibonacci,label=lis:iter-fibo]
int fib(int n) {
  int a = 0, b = 1;
  for (int i = 0; i < n; i++) {
    int tmp = a + b;
    a = b;
    b = tmp;
  }
  return a;
}
\end{lstlisting}
The two code fragments will return the same result for any $n \geq 0$ and are
therefore functional clones. Although the implemented functionality
is the same, there are no other common point in the implementations.
Furthermore, Listing~\ref{lis:fibo} and Listing~\ref{lis:iter-fibo} clearly
have different time complexities, but to the best of our knowledge, there
are no established convention to whether this kind of complexity changes
should be taken into account when deciding if two code fragments are, or not,
type IV code clones. In this thesis, we will therefore assume that as long
as two code fragments implement same functionality, they are type IV clones.
\subsection{Approaches to clone detection}
There exist various methods to clone detection, which take advantage of the
different source code representations described in
section~\ref{sec:code-representation}. We will present the major
approaches found in the literature.
\subsubsection{Text-based detection}
Text-based clone detection are based on the string representation of the program
source code described in~\ref{ssec:string-representation}.
While some text-based techniques use the source code almost as is and perform
either line-by-line or global string comparisons to find clones, some techniques
do apply some preprocessing steps \cite{Baker92aprogram}, such as removing white
spaces, before actually passing the source code to a string matching algorithm.
\subsubsection{Token-based detection}
Token-based detection techniques use the token representation of the program
described in~\ref{ssec:token-representation}. Token-based approach are usually
more robust to formatting and layout changes compared to text-based approaches.
Some token-based clone detection tools, such as CCFinder
\cite{Kamiya:2002:CMT:636188.636191} first normalize the tokens and replace all
application specific tokens such as user-defined identifiers. On the other hand,
other tools such as SourcererCC \cite{Sajnani:2016:SSC:2884781.2884877} keep
this information and use it to detect if multiple code fragments are clones or
not.
\subsubsection{Tree-based detection}
Tree-based techniques make use of the AST representation of the program
described in \ref{ssec:tree-representation}. These techniques first use a parser
to generate the AST of a program, then the ASTs are searched for similar
sub-trees and similar sub-trees are marked as clones. Searching for similar
sub-trees using normal tree comparisons algorithms takes at least
$\mathcal{O}\left(n^3\right)$ \cite{Baxter:1998:CDU:850947.853341}, where $n$ is
the number of nodes. Industrial software can have millions of line of codes, and
therefore $n$ could be in the order of 10 million. To avoid this issue, many
tree-based clone detection techniques \cite{Baxter:1998:CDU:850947.853341,
  Jiang:2007:DSA:1248820.1248843} use hash functions on sub-tress to find clones
more efficiently. The idea is to assign each sub-tree a hash-value, and use this
value, usually with bucketing techniques, to quickly search for code clones.
\section{Machine learning fundamentals}
In this section, we will present the basics of machine learning that will be
needed in order to understand our approach. We will first give a general
overview of the learning process of neural networks, then we will describe
the two models we are using as a base to our work in this thesis.
The first model will present is the skipgram model, which is typically used in
natural language processing (NLP) to assign a vector representation to a word.
Next, we will give an overview of recurrent neural networks (RNN), and in
particular long-short term memory (LSTM) networks, which are extensively used in
NLP to assign a vector representation to a sentence.
\subsection{Neural networks}
In this subsection, we will show how are neural network composed, and what is
the normal process to train them. Although most of what we explain here apply to
most machine learning algorithms, we will focus on feed-forward neural networks.
\subsubsection{Computations of a neural network}
A neural network \cite{Rojas:1996:NNS:235222} is usually composed of an input
layer, which is where the input data is fed, one or more hidden layers, and an
output layer, which represents the value outputted by the neural network.
Each layer in the network is composed by units, also sometimes referred to as
neurons, which are the computing elements of the network. Each unit is usually
composed of two different parts: a first function $f$, which reduces a vector
into a single scalar value, and a function $g$, called ``activation function''
which transforms the result of $f$ and produces the unit output. This function
is generally non-linear, otherwise the model ends up to be composed of only
linear function and becomes as well a linear function.
A unit of a neural network is illustrated in figure \ref{fig:neuron}.
\begin{figure}[tb]
  \centering\input{diagrams/nn-unit}
  \caption{\label{fig:neuron}Unit of a neural network}
\end{figure}
Each layer is connected to the next one by using the output of each unit of the
previous layer as an input for each unit of the next layer. This connection is
illustrated in figure \ref{fig:neural-net}.
\begin{figure}[tb]
  \centering\input{diagrams/neural-net}
  \caption{\label{fig:neural-net}Neural network}
\end{figure}

The function $f$ is a matrix multiplication where all the weights of this matrix
are parameters of the neural network model. Matrix weights are shared by all the
units in a layer. In figure \ref{fig:neural-net}, given $W^{(1)} \in
mathbb{R}^{5\times 3}$ is the matrix weights of the hidden layer, $W_{mn}$ is
the value at row $m$ and column $n$ in this matrix, $g_1$ is the activation
function of the hidden layer, and $a_1, a_2$ and $a_3$ the output of each unit
in the layer, we will have the following.
\begin{align*}
  a_1 &= g\left( W_{11}^{(1)}x_1 + \cdots + W_{51}^{(1)}x_5 \right)\\
  a_2 &= g\left( W_{12}^{(1)}x_1 + \cdots + W_{52}^{(1)}x_5 \right)\\
  a_3 &= g\left(W_{13}^{(1)}x_1 + \cdots + W_{53}^{(1)}x_5 \right)
\end{align*}
In practice, given $x = (x_1, \cdots, x_5)$ and $a = (a_1, a_2, a_3)$, the above
is usually computed as follow, with a single matrix multiplication and a
vectorized implementation of the function $g$.

\[ a = g\left(  x W^{(1)}  \right) \]

Finally, given $W^{(2)} \in \mathbb{R}^{3\times 1}$ the weights of the output
layer and $g_2$ the activation of the output layer, the output $o$ of the neural
network will be computed as follow.

\begin{equation}
  o = g_2\left( g_1\left( x W^{(1)} \right) W^{(2)} \right)
\end{equation}
\subsubsection{Training of a neural network}
\subsection{Skipgram model}
As mentioned above, skipgram is used to assign a vector in $\mathbb{R}^d$ to a
word, where $d$ is the number of dimensions wanted for each word vector.
\subsection{Recurrent Neural Networks}
