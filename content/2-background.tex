\chapter{Background}
\section{Source code representation}
The way we represent source code is very important in code clone detection,
as it affects greatly the algorithms that may be used to detect clones.k
In this section, we will explain the different ways in which source codes
can be represented.
\section{Code clone fundamentals}
In this section, we will first describe the different types of code clones
that appear in the literature, and that we will be using in this thesis.
We will then quickly view the different approaches to code clone detection,
and briefly discuss their strengths and weaknesses.
\subsection{Types of code clones}
It is important to define what is implied when two code fragments are
defined as clones. In the literature, code clones are usually
classified into four different types~\cite{Roy07asurvey}, from Type I to Type IV,
where Type I is the ``strongest'', meaning here that the two code fragments are
the most similar, while Type IV is the ``weakest'' --- the two code fragments
share less in common. We will now give a more precise definition of each code
clone type.
\subsubsection{Type I Clones}
Type I code clones types are clones where the code fragment are the same,
except for some variations that do not affect the logic, such as differences
in whitespaces or comments. In the literature, Type I clones are sometimes also
referred to as exact clones.
For example, let us consider the following code fragment.
\begin{lstlisting}[caption=Fibonacci function,label=lis:fibo]
int fibo(int n) {
  if (n <= 1) {
    return n;
  }
  return fibo(n - 1) + fibo(n - 2);
}
\end{lstlisting}

The following code fragment is considered to be a Type I clone.
\begin{lstlisting}
int fibo(int n) {
  if (n <= 1) { return n; } // base case of recursion
  return fibo(n-1)+
         fibo(n-2);
}
\end{lstlisting}

Although, as with the above example, line-by-line comparisons may not always
yield correct results for Type I clones, it is worth noting than if the two
fragments are pre-processed with a lexer, a simple token comparison should
normally be enough to detect this type of clones.
\subsubsection{Type II Clones}
Type II clones include the changes that can be involved in Type I clones, such
as layout and comments, but also include other changes, such as changes in
user-defined identifiers --- variable or function names. For example, the
following snippet would be a Type II clone for Listing~\ref{lis:fibo}:
\begin{lstlisting}
int fib(int x) {
  if (x <= 1) { return x; }
  return fib(x - 1) + fib(x - 2);
}
\end{lstlisting}
The function and parameter names, as well as the layout are different, but the
logic is exactly the same.
\subsubsection{Type III Clones}
Type III clones can have all the changes from type I and type II clones, but
may also have statement insertions, deletions or replacements.
Although Type III clones are usually copied from the same source code,
there is no agreement on a threshold on the number of changes to consider or not
two code fragments as type III clones. Some researchers therefore classify
type III code clones in categories such as very strong type III or weakly type
III~\cite{Sajnani:2016:SSC:2884781.2884877}.
Here is an example type III clone for Listing~\ref{lis:fibo}.
%
\begin{lstlisting}
int fib(int x) {
  int a = x;
  if (a <= 1) {
    return a;
  }
  return fib(a - 1) + fib(a - 2);
}
\end{lstlisting}

In the above code fragment, the code is completely copied from
Listing~\ref{lis:fibo}, except for a change in the identifier names, but the
second line has been inserted, making this code fragment a type III clone.
\subsubsection{Type IV Clones}
Type IV clones, also referred to as functional code clones, are two code
fragments implementing the same functionality with different approaches.
Unlike type I to III clones, type IV clones are usually not a result of
code copying, but rather of two programmers implementing the same functionality.
For example, as opposed to the recursive implementation of Fibonacci in
Listing~\ref{lis:fibo}, the following iterative implementation could be defined
to be a type IV clone.
\begin{lstlisting}[caption=Iterative Fibonacci,label=lis:iter-fibo]
int fib(int n) {
  int a = 0, b = 1;
  for (int i = 0; i < n; i++) {
    int tmp = a + b;
    a = b;
    b = tmp;
  }
  return a;
}
\end{lstlisting}
The two code fragments will return the same result for any $n \geq 0$ and are
therefore functional clones. Although the implemented functionality
is the same, there are no other common point in the implementations.
Furthermore, Listing~\ref{lis:fibo} and Listing~\ref{lis:iter-fibo} clearly
have different time complexities, but to the best of our knowledge, there
are no established convention to whether this kind of complexity changes
should be taken into account when deciding if two code fragments are, or not,
type IV code clones. In this thesis, we will therefore assume that as long
as two code fragments implement same functionality, they are type IV clones.

\subsection{Approaches to clone detection}
\section{Machine learning fundamentals}
\subsection{Skipgram model}
\subsection{Recurrent Neural Networks}
